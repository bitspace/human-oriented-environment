#!/usr/bin/env python3
"""
Claude NixOS Helper
Specialized interface for Claude Code to interact with NixOS configurations
Provides safe, structured commands for LLM-driven system management
Author: Generated by Claude Code synthesis
Date: 2025-08-12
"""

import json
import re
import subprocess
import sys
from pathlib import Path
from typing import Dict, List, Optional, Any, Tuple
from llm_config_manager import NixConfigManager
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class ClaudeNixOSHelper:
    """Helper class for Claude Code to safely manage NixOS configurations"""
    
    def __init__(self):
        self.config_manager = NixConfigManager()
        self.safe_commands = {
            'get_system_info',
            'list_packages',
            'search_package',
            'validate_config', 
            'backup_configs',
            'list_backups',
            'get_config_snippet',
            'suggest_packages',
            'check_hardware_support',
            'get_service_status',
            'explain_option'
        }
        self.privileged_commands = {
            'add_package',
            'remove_package',
            'modify_config',
            'apply_config',
            'rollback_config',
            'enable_service',
            'disable_service'
        }
    
    def execute_safe_command(self, command: str, **kwargs) -> Dict[str, Any]:
        """Execute safe read-only commands"""
        if command not in self.safe_commands:
            return {"error": f"Command {command} not in safe commands list"}
        
        try:
            method = getattr(self, command)
            return method(**kwargs)
        except Exception as e:
            logger.error(f"Safe command {command} failed: {e}")
            return {"error": str(e)}
    
    def execute_privileged_command(self, command: str, confirm: bool = False, **kwargs) -> Dict[str, Any]:
        """Execute privileged commands that modify system state"""
        if command not in self.privileged_commands:
            return {"error": f"Command {command} not in privileged commands list"}
        
        if not confirm:
            return {
                "error": "Privileged command requires confirmation",
                "command": command,
                "kwargs": kwargs,
                "confirmation_required": True
            }
        
        try:
            # Create backup before privileged operations
            backup_path = self.config_manager.backup_configs()
            logger.info(f"Created backup: {backup_path}")
            
            method = getattr(self, command)
            result = method(**kwargs)
            result["backup_created"] = backup_path
            return result
        except Exception as e:
            logger.error(f"Privileged command {command} failed: {e}")
            return {"error": str(e)}
    
    # Safe Commands (read-only)
    
    def get_system_info(self) -> Dict[str, Any]:
        """Get comprehensive system information"""
        try:
            system_info = self.config_manager.get_system_info()
            metadata = self.config_manager.export_llm_metadata()
            
            return {
                "system_info": system_info.__dict__,
                "metadata": metadata,
                "available_commands": {
                    "safe": list(self.safe_commands),
                    "privileged": list(self.privileged_commands)
                }
            }
        except Exception as e:
            return {"error": str(e)}
    
    def list_packages(self, pattern: Optional[str] = None) -> Dict[str, Any]:
        """List installed packages, optionally filtered by pattern"""
        try:
            # Get system packages
            system_cmd = ["nix-env", "-qa", "--installed"]
            if pattern:
                system_cmd.extend(["--attr-path", f".*{pattern}.*"])
            
            result = subprocess.run(system_cmd, capture_output=True, text=True)
            system_packages = result.stdout.strip().split('\n') if result.stdout.strip() else []
            
            # Get user packages (if home-manager is available)
            user_packages = []
            try:
                user_cmd = ["home-manager", "packages"]
                result = subprocess.run(user_cmd, capture_output=True, text=True)
                user_packages = result.stdout.strip().split('\n') if result.stdout.strip() else []
            except:
                pass  # home-manager not available or not configured
            
            return {
                "system_packages": system_packages,
                "user_packages": user_packages,
                "total_count": len(system_packages) + len(user_packages)
            }
        except Exception as e:
            return {"error": str(e)}
    
    def search_package(self, query: str, limit: int = 20) -> Dict[str, Any]:
        """Search for packages in nixpkgs"""
        try:
            cmd = ["nix", "search", "nixpkgs", query, "--json"]
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)
            
            if result.returncode == 0:
                packages = json.loads(result.stdout)
                # Limit results and format for readability
                limited_packages = dict(list(packages.items())[:limit])
                
                formatted_results = []
                for name, info in limited_packages.items():
                    formatted_results.append({
                        "name": name,
                        "pname": info.get("pname", ""),
                        "version": info.get("version", ""),
                        "description": info.get("description", "")[:200] + "..." if len(info.get("description", "")) > 200 else info.get("description", "")
                    })
                
                return {
                    "query": query,
                    "results": formatted_results,
                    "total_found": len(packages),
                    "showing": len(limited_packages)
                }
            else:
                return {"error": f"Search failed: {result.stderr}"}
        except subprocess.TimeoutExpired:
            return {"error": "Search timed out"}
        except Exception as e:
            return {"error": str(e)}
    
    def validate_config(self, config_type: str = "nixos") -> Dict[str, Any]:
        """Validate configuration without applying changes"""
        return self.config_manager.validate_config(config_type)
    
    def backup_configs(self) -> Dict[str, Any]:
        """Create backup of current configurations"""
        try:
            backup_path = self.config_manager.backup_configs()
            return {"backup_path": backup_path, "status": "success"}
        except Exception as e:
            return {"error": str(e)}
    
    def list_backups(self) -> Dict[str, Any]:
        """List available configuration backups"""
        try:
            backups = self.config_manager.list_backups()
            return {"backups": backups, "count": len(backups)}
        except Exception as e:
            return {"error": str(e)}
    
    def get_config_snippet(self, module: str, config_type: str = "nixos") -> Dict[str, Any]:
        """Get configuration snippet from a specific module"""
        try:
            if config_type == "nixos":
                config_path = Path("/etc/nixos/modules") / f"{module}.nix"
            else:
                config_path = Path.home() / ".config/home-manager/modules" / f"{module}.nix"
            
            if not config_path.exists():
                return {"error": f"Module {module} not found"}
            
            with open(config_path, 'r') as f:
                content = f.read()
            
            return {
                "module": module,
                "config_type": config_type,
                "path": str(config_path),
                "content": content,
                "lines": len(content.split('\n'))
            }
        except Exception as e:
            return {"error": str(e)}
    
    def suggest_packages(self, category: str) -> Dict[str, Any]:
        """Suggest packages for specific categories"""
        suggestions = {
            "development": [
                "git", "neovim", "vscode", "docker", "nodejs", "python3",
                "rustup", "go", "gcc", "cmake", "postman"
            ],
            "media": [
                "vlc", "gimp", "obs-studio", "audacity", "blender",
                "kdenlive", "firefox", "chromium"
            ],
            "productivity": [
                "libreoffice", "obsidian", "discord", "telegram-desktop",
                "thunderbird", "calibre", "nextcloud-client"
            ],
            "gaming": [
                "steam", "lutris", "wine", "heroic", "mangohud",
                "gamemode", "bottles"
            ],
            "system": [
                "htop", "neofetch", "tree", "fd", "ripgrep", "bat",
                "exa", "zoxide", "fzf"
            ],
            "security": [
                "gnupg", "pass", "keepassxc", "bitwarden",
                "tor-browser-bundle-bin", "wireshark"
            ]
        }
        
        category_suggestions = suggestions.get(category.lower(), [])
        if not category_suggestions:
            available_categories = list(suggestions.keys())
            return {
                "error": f"Category {category} not found",
                "available_categories": available_categories
            }
        
        return {
            "category": category,
            "suggestions": category_suggestions,
            "count": len(category_suggestions)
        }
    
    def check_hardware_support(self, hardware_type: str) -> Dict[str, Any]:
        """Check hardware support for specific components"""
        hardware_checks = {
            "gpu": self._check_gpu_support,
            "audio": self._check_audio_support,
            "bluetooth": self._check_bluetooth_support,
            "wifi": self._check_wifi_support,
            "webcam": self._check_webcam_support
        }
        
        if hardware_type not in hardware_checks:
            return {
                "error": f"Hardware type {hardware_type} not supported",
                "available_types": list(hardware_checks.keys())
            }
        
        try:
            return hardware_checks[hardware_type]()
        except Exception as e:
            return {"error": str(e)}
    
    def _check_gpu_support(self) -> Dict[str, Any]:
        """Check GPU support status"""
        try:
            # Check for GPU devices
            lspci_result = subprocess.run(
                ["lspci", "-nn", "|", "grep", "-E", "VGA|3D|Display"],
                shell=True, capture_output=True, text=True
            )
            
            gpu_info = []
            if lspci_result.stdout:
                gpu_info = lspci_result.stdout.strip().split('\n')
            
            # Check loaded drivers
            lsmod_result = subprocess.run(
                ["lsmod", "|", "grep", "-E", "i915|nouveau|amdgpu|radeon|nvidia"],
                shell=True, capture_output=True, text=True
            )
            
            drivers = []
            if lsmod_result.stdout:
                drivers = lsmod_result.stdout.strip().split('\n')
            
            return {
                "hardware_type": "gpu",
                "devices": gpu_info,
                "loaded_drivers": drivers,
                "status": "detected" if gpu_info else "not_detected"
            }
        except Exception as e:
            return {"error": str(e)}
    
    def _check_audio_support(self) -> Dict[str, Any]:
        """Check audio system status"""
        try:
            # Check PipeWire status
            pw_status = subprocess.run(
                ["systemctl", "--user", "is-active", "pipewire"],
                capture_output=True, text=True
            )
            
            # Check audio devices
            devices_result = subprocess.run(
                ["pactl", "list", "short", "sinks"],
                capture_output=True, text=True
            )
            
            devices = devices_result.stdout.strip().split('\n') if devices_result.stdout else []
            
            return {
                "hardware_type": "audio",
                "pipewire_status": pw_status.stdout.strip(),
                "audio_devices": devices,
                "status": "active" if pw_status.returncode == 0 else "inactive"
            }
        except Exception as e:
            return {"error": str(e)}
    
    def _check_bluetooth_support(self) -> Dict[str, Any]:
        """Check Bluetooth support status"""
        try:
            # Check Bluetooth service
            bt_status = subprocess.run(
                ["systemctl", "is-active", "bluetooth"],
                capture_output=True, text=True
            )
            
            # Check Bluetooth devices
            devices_result = subprocess.run(
                ["bluetoothctl", "list"],
                capture_output=True, text=True
            )
            
            return {
                "hardware_type": "bluetooth",
                "service_status": bt_status.stdout.strip(),
                "controllers": devices_result.stdout.strip() if devices_result.stdout else "none",
                "status": "active" if bt_status.returncode == 0 else "inactive"
            }
        except Exception as e:
            return {"error": str(e)}
    
    def _check_wifi_support(self) -> Dict[str, Any]:
        """Check WiFi support status"""
        try:
            # Check WiFi interfaces
            interfaces_result = subprocess.run(
                ["nmcli", "device", "status"],
                capture_output=True, text=True
            )
            
            wifi_interfaces = []
            if interfaces_result.stdout:
                lines = interfaces_result.stdout.strip().split('\n')[1:]  # Skip header
                wifi_interfaces = [line for line in lines if 'wifi' in line.lower()]
            
            return {
                "hardware_type": "wifi",
                "interfaces": wifi_interfaces,
                "status": "available" if wifi_interfaces else "not_available"
            }
        except Exception as e:
            return {"error": str(e)}
    
    def _check_webcam_support(self) -> Dict[str, Any]:
        """Check webcam support status"""
        try:
            # Check video devices
            devices_result = subprocess.run(
                ["ls", "/dev/video*"],
                capture_output=True, text=True, shell=True
            )
            
            video_devices = []
            if devices_result.stdout:
                video_devices = devices_result.stdout.strip().split()
            
            return {
                "hardware_type": "webcam",
                "video_devices": video_devices,
                "status": "detected" if video_devices else "not_detected"
            }
        except Exception as e:
            return {"error": str(e)}
    
    def get_service_status(self, service_name: str) -> Dict[str, Any]:
        """Get systemd service status"""
        try:
            # Check system service
            system_status = subprocess.run(
                ["systemctl", "is-active", service_name],
                capture_output=True, text=True
            )
            
            # Check user service
            user_status = subprocess.run(
                ["systemctl", "--user", "is-active", service_name],
                capture_output=True, text=True
            )
            
            # Get detailed status if active
            details = {}
            if system_status.returncode == 0 or user_status.returncode == 0:
                active_scope = "system" if system_status.returncode == 0 else "user"
                cmd = ["systemctl", "status", service_name]
                if active_scope == "user":
                    cmd.insert(1, "--user")
                
                status_result = subprocess.run(cmd, capture_output=True, text=True)
                details["full_status"] = status_result.stdout
            
            return {
                "service": service_name,
                "system_status": system_status.stdout.strip(),
                "user_status": user_status.stdout.strip(),
                "details": details
            }
        except Exception as e:
            return {"error": str(e)}
    
    def explain_option(self, option_path: str) -> Dict[str, Any]:
        """Explain a NixOS configuration option"""
        try:
            cmd = ["nixos-option", option_path]
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=10)
            
            if result.returncode == 0:
                return {
                    "option": option_path,
                    "explanation": result.stdout.strip(),
                    "status": "found"
                }
            else:
                return {
                    "option": option_path,
                    "error": result.stderr.strip(),
                    "status": "not_found"
                }
        except subprocess.TimeoutExpired:
            return {"error": "Option lookup timed out"}
        except Exception as e:
            return {"error": str(e)}
    
    # Privileged Commands (require confirmation and create backups)
    
    def add_package(self, package_name: str, config_type: str = "nixos") -> Dict[str, Any]:
        """Add package to configuration"""
        try:
            # This is a template - actual implementation would modify the appropriate .nix file
            result = {
                "action": "add_package",
                "package": package_name,
                "config_type": config_type,
                "status": "ready_to_apply",
                "warning": "This is a template implementation. Real implementation would modify the .nix configuration files."
            }
            
            return result
        except Exception as e:
            return {"error": str(e)}
    
    def apply_config(self, config_type: str = "nixos", test_mode: bool = False) -> Dict[str, Any]:
        """Apply configuration changes"""
        return self.config_manager.apply_config(config_type, test_mode)
    
    def rollback_config(self, backup_name: str) -> Dict[str, Any]:
        """Rollback to a previous configuration"""
        return self.config_manager.rollback_to_backup(backup_name)

def main():
    """CLI interface for Claude NixOS Helper"""
    if len(sys.argv) < 2:
        print(json.dumps({"error": "No command specified"}))
        sys.exit(1)
    
    helper = ClaudeNixOSHelper()
    command = sys.argv[1]
    
    # Parse additional arguments as JSON if provided
    kwargs = {}
    if len(sys.argv) > 2:
        try:
            kwargs = json.loads(sys.argv[2])
        except json.JSONDecodeError:
            # Try parsing as key=value pairs
            for arg in sys.argv[2:]:
                if '=' in arg:
                    key, value = arg.split('=', 1)
                    kwargs[key] = value
    
    # Execute command
    if command in helper.safe_commands:
        result = helper.execute_safe_command(command, **kwargs)
    elif command in helper.privileged_commands:
        confirm = kwargs.pop('confirm', False)
        result = helper.execute_privileged_command(command, confirm=confirm, **kwargs)
    else:
        result = {"error": f"Unknown command: {command}"}
    
    print(json.dumps(result, indent=2))

if __name__ == "__main__":
    main()