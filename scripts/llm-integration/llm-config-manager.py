#!/usr/bin/env python3
"""
LLM Configuration Manager for NixOS
Provides structured interface for LLM agents to manage system configuration
Author: Generated by Claude Code synthesis
Date: 2025-08-12
"""

import json
import yaml
import subprocess
import os
import sys
import argparse
import logging
from pathlib import Path
from typing import Dict, List, Optional, Any
from dataclasses import dataclass, asdict
from datetime import datetime
import tempfile
import shutil

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S'
)
logger = logging.getLogger(__name__)

@dataclass
class SystemInfo:
    """System information for LLM agents"""
    hostname: str
    username: str
    nixos_version: str
    kernel_version: str
    desktop_environment: str
    last_updated: str
    config_path: str
    home_config_path: str

@dataclass 
class ConfigChange:
    """Represents a configuration change"""
    timestamp: str
    module: str
    change_type: str  # 'add', 'modify', 'remove'
    description: str
    old_value: Optional[str] = None
    new_value: Optional[str] = None

class NixConfigManager:
    """Manages NixOS configuration for LLM agents"""
    
    def __init__(self):
        self.nixos_config_path = Path("/etc/nixos")
        self.home_config_path = Path.home() / ".config" / "home-manager"
        self.backup_path = Path.home() / ".config" / "nixos-llm-backups"
        self.changes_log = Path.home() / ".config" / "nixos-changes.json"
        
        # Ensure directories exist
        self.backup_path.mkdir(parents=True, exist_ok=True)
        
        # Load change history
        self.changes = self._load_changes()
        
    def _load_changes(self) -> List[ConfigChange]:
        """Load change history from JSON file"""
        if not self.changes_log.exists():
            return []
        
        try:
            with open(self.changes_log, 'r') as f:
                data = json.load(f)
                return [ConfigChange(**item) for item in data]
        except Exception as e:
            logger.error(f"Failed to load changes log: {e}")
            return []
    
    def _save_changes(self):
        """Save change history to JSON file"""
        try:
            data = [asdict(change) for change in self.changes]
            with open(self.changes_log, 'w') as f:
                json.dump(data, f, indent=2)
        except Exception as e:
            logger.error(f"Failed to save changes log: {e}")
    
    def _log_change(self, module: str, change_type: str, description: str, 
                   old_value: Optional[str] = None, new_value: Optional[str] = None):
        """Log a configuration change"""
        change = ConfigChange(
            timestamp=datetime.now().isoformat(),
            module=module,
            change_type=change_type,
            description=description,
            old_value=old_value,
            new_value=new_value
        )
        self.changes.append(change)
        self._save_changes()
        logger.info(f"Logged change: {description}")
    
    def get_system_info(self) -> SystemInfo:
        """Get current system information"""
        try:
            # Get hostname
            hostname = subprocess.check_output(['hostname'], text=True).strip()
            
            # Get username
            username = os.getenv('USER', 'unknown')
            
            # Get NixOS version
            try:
                nixos_version = subprocess.check_output(
                    ['nixos-version'], text=True
                ).strip()
            except subprocess.CalledProcessError:
                nixos_version = "unknown"
            
            # Get kernel version
            kernel_version = subprocess.check_output(
                ['uname', '-r'], text=True
            ).strip()
            
            # Desktop environment
            desktop_environment = "hyprland"  # Based on our configuration
            
            # Last updated
            config_file = self.nixos_config_path / "configuration.nix"
            if config_file.exists():
                mtime = datetime.fromtimestamp(config_file.stat().st_mtime)
                last_updated = mtime.isoformat()
            else:
                last_updated = "unknown"
            
            return SystemInfo(
                hostname=hostname,
                username=username,
                nixos_version=nixos_version,
                kernel_version=kernel_version,
                desktop_environment=desktop_environment,
                last_updated=last_updated,
                config_path=str(self.nixos_config_path),
                home_config_path=str(self.home_config_path)
            )
        except Exception as e:
            logger.error(f"Failed to get system info: {e}")
            raise
    
    def backup_configs(self) -> str:
        """Create backup of current configurations"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_dir = self.backup_path / f"backup_{timestamp}"
        
        try:
            backup_dir.mkdir(parents=True)
            
            # Backup NixOS config (if accessible)
            if self.nixos_config_path.exists() and os.access(self.nixos_config_path, os.R_OK):
                nixos_backup = backup_dir / "nixos"
                shutil.copytree(self.nixos_config_path, nixos_backup, symlinks=True)
            
            # Backup Home Manager config
            if self.home_config_path.exists():
                home_backup = backup_dir / "home-manager"
                shutil.copytree(self.home_config_path, home_backup, symlinks=True)
            
            self._log_change(
                "backup", "create", f"Created backup at {backup_dir}"
            )
            
            logger.info(f"Backup created at {backup_dir}")
            return str(backup_dir)
        
        except Exception as e:
            logger.error(f"Failed to create backup: {e}")
            raise
    
    def validate_config(self, config_type: str = "nixos") -> Dict[str, Any]:
        """Validate configuration before applying"""
        result = {
            "valid": False,
            "errors": [],
            "warnings": []
        }
        
        try:
            if config_type == "nixos":
                # Validate NixOS configuration
                cmd = ["sudo", "nixos-rebuild", "dry-build"]
                proc = subprocess.run(
                    cmd, capture_output=True, text=True, timeout=300
                )
                
                if proc.returncode == 0:
                    result["valid"] = True
                    result["message"] = "NixOS configuration is valid"
                else:
                    result["errors"].append(proc.stderr)
                    result["message"] = "NixOS configuration has errors"
            
            elif config_type == "home":
                # Validate Home Manager configuration  
                cmd = ["home-manager", "build"]
                proc = subprocess.run(
                    cmd, capture_output=True, text=True, timeout=300,
                    cwd=self.home_config_path
                )
                
                if proc.returncode == 0:
                    result["valid"] = True
                    result["message"] = "Home Manager configuration is valid"
                else:
                    result["errors"].append(proc.stderr)
                    result["message"] = "Home Manager configuration has errors"
            
            logger.info(f"Configuration validation result: {result['message']}")
            return result
        
        except subprocess.TimeoutExpired:
            result["errors"].append("Validation timeout")
            result["message"] = "Configuration validation timed out"
            return result
        except Exception as e:
            result["errors"].append(str(e))
            result["message"] = f"Validation failed: {e}"
            return result
    
    def apply_config(self, config_type: str = "nixos", test_mode: bool = False) -> Dict[str, Any]:
        """Apply configuration changes"""
        result = {
            "success": False,
            "message": "",
            "generation": None
        }
        
        try:
            # Create backup before applying changes
            backup_dir = self.backup_configs()
            
            if config_type == "nixos":
                if test_mode:
                    cmd = ["sudo", "nixos-rebuild", "test"]
                else:
                    cmd = ["sudo", "nixos-rebuild", "switch"]
                
                proc = subprocess.run(
                    cmd, capture_output=True, text=True, timeout=1800  # 30 minutes
                )
                
                if proc.returncode == 0:
                    result["success"] = True
                    result["message"] = f"NixOS configuration applied successfully ({'test' if test_mode else 'permanent'})"
                    
                    # Extract generation number if available
                    output = proc.stdout
                    if "activating the configuration..." in output:
                        # Try to extract generation info
                        try:
                            gen_info = subprocess.check_output(
                                ["nixos-rebuild", "list-generations", "--max-generations", "1"],
                                text=True
                            ).strip().split('\n')[-1]
                            result["generation"] = gen_info
                        except:
                            pass
                else:
                    result["message"] = f"Failed to apply NixOS configuration: {proc.stderr}"
            
            elif config_type == "home":
                cmd = ["home-manager", "switch"]
                proc = subprocess.run(
                    cmd, capture_output=True, text=True, timeout=1800,
                    cwd=self.home_config_path
                )
                
                if proc.returncode == 0:
                    result["success"] = True
                    result["message"] = "Home Manager configuration applied successfully"
                else:
                    result["message"] = f"Failed to apply Home Manager configuration: {proc.stderr}"
            
            # Log the change
            self._log_change(
                config_type, 
                "apply", 
                f"Applied {config_type} configuration ({'test' if test_mode else 'permanent'})",
                old_value=backup_dir,
                new_value="active"
            )
            
            logger.info(result["message"])
            return result
        
        except subprocess.TimeoutExpired:
            result["message"] = "Configuration apply timed out"
            return result
        except Exception as e:
            result["message"] = f"Failed to apply configuration: {e}"
            return result
    
    def rollback_to_backup(self, backup_name: str) -> Dict[str, Any]:
        """Rollback to a specific backup"""
        result = {
            "success": False,
            "message": ""
        }
        
        try:
            backup_dir = self.backup_path / backup_name
            if not backup_dir.exists():
                result["message"] = f"Backup {backup_name} not found"
                return result
            
            # Create current backup before rollback
            current_backup = self.backup_configs()
            
            # Restore NixOS config (requires sudo)
            nixos_backup = backup_dir / "nixos"
            if nixos_backup.exists():
                cmd = ["sudo", "cp", "-r", str(nixos_backup) + "/.", str(self.nixos_config_path)]
                proc = subprocess.run(cmd, capture_output=True, text=True)
                if proc.returncode != 0:
                    result["message"] = f"Failed to restore NixOS config: {proc.stderr}"
                    return result
            
            # Restore Home Manager config
            home_backup = backup_dir / "home-manager"
            if home_backup.exists():
                if self.home_config_path.exists():
                    shutil.rmtree(self.home_config_path)
                shutil.copytree(home_backup, self.home_config_path, symlinks=True)
            
            self._log_change(
                "rollback", "restore", f"Rolled back to backup {backup_name}",
                old_value="current",
                new_value=backup_name
            )
            
            result["success"] = True
            result["message"] = f"Successfully rolled back to {backup_name}"
            logger.info(result["message"])
            return result
        
        except Exception as e:
            result["message"] = f"Rollback failed: {e}"
            return result
    
    def list_backups(self) -> List[Dict[str, Any]]:
        """List available backups"""
        backups = []
        try:
            for backup_dir in sorted(self.backup_path.iterdir(), reverse=True):
                if backup_dir.is_dir() and backup_dir.name.startswith("backup_"):
                    stat = backup_dir.stat()
                    backups.append({
                        "name": backup_dir.name,
                        "path": str(backup_dir),
                        "created": datetime.fromtimestamp(stat.st_mtime).isoformat(),
                        "size": sum(f.stat().st_size for f in backup_dir.rglob('*') if f.is_file())
                    })
        except Exception as e:
            logger.error(f"Failed to list backups: {e}")
        
        return backups
    
    def get_recent_changes(self, limit: int = 10) -> List[Dict[str, Any]]:
        """Get recent configuration changes"""
        return [asdict(change) for change in self.changes[-limit:]]
    
    def export_llm_metadata(self) -> Dict[str, Any]:
        """Export system metadata for LLM agents"""
        try:
            system_info = self.get_system_info()
            
            metadata = {
                "system": asdict(system_info),
                "config_structure": {
                    "nixos_modules": self._list_nixos_modules(),
                    "home_modules": self._list_home_modules(),
                },
                "recent_changes": self.get_recent_changes(5),
                "available_backups": len(self.list_backups()),
                "last_updated": datetime.now().isoformat()
            }
            
            return metadata
        except Exception as e:
            logger.error(f"Failed to export metadata: {e}")
            return {}
    
    def _list_nixos_modules(self) -> List[str]:
        """List available NixOS modules"""
        modules = []
        modules_path = self.nixos_config_path / "modules"
        if modules_path.exists():
            modules = [f.stem for f in modules_path.glob("*.nix")]
        return modules
    
    def _list_home_modules(self) -> List[str]:
        """List available Home Manager modules"""
        modules = []
        modules_path = self.home_config_path / "modules"
        if modules_path.exists():
            modules = [f.stem for f in modules_path.glob("*.nix")]
        return modules

def main():
    """Main CLI interface"""
    parser = argparse.ArgumentParser(description="LLM Configuration Manager for NixOS")
    parser.add_argument("--debug", action="store_true", help="Enable debug logging")
    
    subparsers = parser.add_subparsers(dest="command", help="Available commands")
    
    # System info command
    subparsers.add_parser("info", help="Show system information")
    
    # Backup commands
    backup_parser = subparsers.add_parser("backup", help="Create configuration backup")
    
    # Validation commands
    validate_parser = subparsers.add_parser("validate", help="Validate configuration")
    validate_parser.add_argument("--type", choices=["nixos", "home"], default="nixos")
    
    # Apply commands
    apply_parser = subparsers.add_parser("apply", help="Apply configuration")
    apply_parser.add_argument("--type", choices=["nixos", "home"], default="nixos") 
    apply_parser.add_argument("--test", action="store_true", help="Test mode (temporary)")
    
    # Rollback commands
    rollback_parser = subparsers.add_parser("rollback", help="Rollback to backup")
    rollback_parser.add_argument("backup_name", help="Backup name to rollback to")
    
    # List commands
    list_parser = subparsers.add_parser("list", help="List items")
    list_parser.add_argument("item", choices=["backups", "changes"], help="What to list")
    list_parser.add_argument("--limit", type=int, default=10, help="Limit results")
    
    # Export commands
    subparsers.add_parser("export", help="Export LLM metadata")
    
    args = parser.parse_args()
    
    if args.debug:
        logging.getLogger().setLevel(logging.DEBUG)
    
    manager = NixConfigManager()
    
    try:
        if args.command == "info":
            info = manager.get_system_info()
            print(json.dumps(asdict(info), indent=2))
        
        elif args.command == "backup":
            backup_dir = manager.backup_configs()
            print(json.dumps({"backup_path": backup_dir}))
        
        elif args.command == "validate":
            result = manager.validate_config(args.type)
            print(json.dumps(result, indent=2))
            sys.exit(0 if result["valid"] else 1)
        
        elif args.command == "apply":
            result = manager.apply_config(args.type, args.test)
            print(json.dumps(result, indent=2))
            sys.exit(0 if result["success"] else 1)
        
        elif args.command == "rollback":
            result = manager.rollback_to_backup(args.backup_name)
            print(json.dumps(result, indent=2))
            sys.exit(0 if result["success"] else 1)
        
        elif args.command == "list":
            if args.item == "backups":
                backups = manager.list_backups()
                print(json.dumps(backups[:args.limit], indent=2))
            elif args.item == "changes":
                changes = manager.get_recent_changes(args.limit)
                print(json.dumps(changes, indent=2))
        
        elif args.command == "export":
            metadata = manager.export_llm_metadata()
            print(json.dumps(metadata, indent=2))
        
        else:
            parser.print_help()
            sys.exit(1)
    
    except Exception as e:
        logger.error(f"Command failed: {e}")
        print(json.dumps({"error": str(e)}))
        sys.exit(1)

if __name__ == "__main__":
    main()